/**
	Project JSON Reader
			json_reader.c

	Parses the project.json of a Scratch project and builds it internally.
	Currently it loads the entire JSON into memory, tokenizes it all with JSMN, and then
	goes through the tokens to build SpriteContexts, ThreadContexts, Block stacks, etc.

	The goal is to not store anything in static memory that doesn't live thoughout the
	entirety of running a project.
**/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "project_path.h"
#include "jsmn/jsmn.h"
#include <cmph.h>
#include "ut/utarray.h"

#include "types/primitives.h"
#include "types/value.h"
#include "types/block.h"
#include "types/thread.h"
#include "types/sprite.h"

#include "value.h"
#include "variables.h"
#include "runtime.h"

struct parsingData_t {
	char *json;
	long jsonSize;

	jsmntok_t *tokens;
	long long int nTokens;
	long unsigned int i;

	cmph_t *mph;
	blockhash noop_hash; // hash "noop" once, use many times
	blockhash doIf_hash;

	UT_array *blockBuffer;
	UT_array *valueBuffer;
	UT_array *indicesBuffer; // used by blocks in the blockBuffer to store indices of blocks or values that they reference
	
	SpriteContext *currentContext;
	UT_array *greenFlagScripts;

	UT_array *valueBuffers; // temporarily store pointers to all of the memory chunks of Values so that they can be freed.
};

// TODO: free value buffers somewhere
static unsigned int nValueBuffers;
static const Value *valueBuffers; // store pointers to all of the memory chunks of Values so that they can be freed.

// macros for convenience
#define json (pd->json)
#define jsonSize (pd->jsonSize)
#define tokens (pd->tokens)
#define nTokens (pd->nTokens)

// calculate pointer to token in the JSON text.
#define gjson(tok) (json+(tok).start)

// get the current token
#define TOKC (tokens[pd->i])
// calculate length of the given token
#define toklen(tok) ((tok).end-(tok).start)
// calculate length of the current token
#define tokclen() (toklen(TOKC))
// check if the current token is equal to the given string.
#define tokceq(str) (strncmp(str, gjson(TOKC), tokclen()) == 0)
// extract the text pointed to by the current token into dst and using tmpLen
#define tokcext(dst) {																									\
		dst = malloc(tokclen());																						\
		if(dst == NULL)																											\
			puts("[FATAL]Could not malloc dst string in tokcext");						\
		memcpy(dst, gjson(TOKC), tokclen()*sizeof(char));										\
		dst[tokclen()] = '\0';																							\
	}

#define hash(key, keylen) ((blockhash)(cmph_search(pd->mph, key, keylen)))
#define HASH() (hash(gjson(TOKC), tokclen()))

static const UT_icd ThreadContext_icd = {sizeof(ThreadContext), NULL, NULL, NULL};
static const UT_icd Block_icd = {sizeof(Block), NULL, NULL, NULL};
static const UT_icd Value_icd = {sizeof(Value), NULL, NULL, NULL};
static const UT_icd pointer_icd = {sizeof(void*), NULL, NULL, NULL};
static const UT_icd unsigned_int_icd = {sizeof(unsigned int), NULL, NULL, NULL};

#define initializeSpriteContext(c) {															\
		c->variables = NULL;																					\
		c->lists = NULL;																							\
		c->xpos = c->ypos = c->layer = c->costumeNumber = 0;					\
		c->direction = 90; c->size = c->volume = 100; c->tempo = 60;	\
		c->effects.color = c->effects.brightness = c->effects.ghost		\
			= c->effects.pixelate = c->effects.mosaic										\
			= c->effects.fisheye = c->effects.whirl											\
			= 0;																												\
	}


static long loadFile(const char *const path, char **const output) {
	FILE *stream = fopen(path, "rb");
	if(stream == NULL) {
		printf("ERROR\n\tThe file `%s` could not be opened\n", path);
		fclose(stream);
		return 0;
	}
	fseek(stream, 0, SEEK_END);
	long sizeofFile = ftell(stream);
	*output = malloc(sizeofFile);
	rewind(stream);
	fread(*output, sizeof(char), sizeofFile, stream);
	fclose(stream);
	return sizeofFile;
}

static inline void tokenize(struct parsingData_t *const pd) {
	jsmn_parser parser;

	// tokenize the file
#define ERROR(s) {puts("[FATAL]"s); return;}
	jsmn_init(&parser);
	nTokens = jsmn_parse(&parser, json, jsonSize, NULL, 0);
	if(nTokens == JSMN_ERROR_INVAL)
		ERROR("JSMN_ERROR_INVAL")
	else if(nTokens == JSMN_ERROR_PART)
		ERROR("JSMN_ERROR_PART")
	tokens = malloc(nTokens*sizeof(jsmntok_t));

	jsmn_init(&parser);
	nTokens = jsmn_parse(&parser, json, jsonSize, tokens, nTokens);
	if(nTokens == JSMN_ERROR_INVAL)
		ERROR("JSMN_ERROR_INVAL")
	else if(nTokens == JSMN_ERROR_PART)
		ERROR("JSMN_ERROR_PART")
	else if(nTokens == JSMN_ERROR_NOMEM)
		ERROR("JSMN_ERROR_NOMEM")
#undef ERROR
}

/* load minimum perfect hash file generated by cmph */
static inline void loadBlockHashFunc(struct parsingData_t *const pd) {
	FILE *stream = fopen(PROJECT_PATH"src/perfect_hashes/blocks.mphf", "r");
	if(stream == NULL)
		puts("[FATAL]Could not load block hash function");
	pd->mph = cmph_load(stream);
	fclose(stream);
}

/* Skips the current token and it's children. Because JSMN makes values children of their
	 keys, calling this when pd->i points to a key will skip the whole key-value pair. */
static void skip(struct parsingData_t *const pd) {
	long unsigned int tokensToSkip = 1;
	do {
		tokensToSkip += TOKC.size; // add child tokens to tokensToSkip
		++pd->i; // skip token
	} while(--tokensToSkip != 0);
}

#define SKIP() skip(pd);
static void parseVariables(struct parsingData_t *const pd) {
	uint16 elementsToGo, propertiesToGo;
	char *name;
	jsmntok_t *valueToken;
	puts("variables");

	++pd->i; // advance to array
	elementsToGo = TOKC.size; // number of variable objects to parse
	
	do { // for each variable object
		++pd->i; // advance to variable object
		propertiesToGo = TOKC.size;
		do { // for each property
			++pd->i; // advance to key
			if(tokceq("name")) {
				++pd->i; // advance to value
				tokcext(name);
			}
			else if(tokceq("value")) {
				++pd->i; // advance to value
				valueToken = tokens+pd->i;
			}
			else
				++pd->i;
		} while(--propertiesToGo != 0);
		createVariable(&pd->currentContext->variables, name, strnToValue(gjson(*valueToken), toklen(*valueToken)));
	} while(--elementsToGo != 0);
	++pd->i; // advance from last property
}

static void parseLists(struct parsingData_t *const pd) {
	uint16 elementsToGo, propertiesToGo;
	char *name;
	const jsmntok_t *valueToken;
	puts("lists");

	++pd->i; // advance to array
	elementsToGo = TOKC.size; // number of list objects to parse

	do { // for each list object
		++pd->i; // advance to list object
		propertiesToGo = TOKC.size;
		do { // for each property
			++pd->i; // advance to key
			if(tokceq("listName")) {
				++pd->i; // advance to value
				tokcext(name);
			}
			else if(tokceq("contents")) {
				valueToken = tokens + ++pd->i;
				pd->i += TOKC.size;
			}
			else
				++pd->i; // advance to value
		} while(--propertiesToGo != 0);
		List* list = createList(&pd->currentContext->lists, name, NULL, 0);
		for(propertiesToGo = valueToken->size; propertiesToGo != 0; --propertiesToGo) {
			++valueToken;
			listAppend(list, strnToValue(gjson(*valueToken), toklen(*valueToken)));
		}
	} while(--elementsToGo != 0);
	++pd->i; // advance from last property
}

/* Parses arguments to a block, using recursion when one of the arguments is another block.
   pd.i should be the index of the opstring of the current block.
   Returns number of substacks left to parse, and leaves pd.i pointing to the substack (array of blocks),
   or 0 if there are no substacks, and leaves pd.i pointing to the last argument. */
static ubyte parseBlockArgs(struct parsingData_t *const pd, uint16 childrenToGo, const ubyte level) {
	Value tmpValue;
	Block tmpBlock = {
		0,
		level,
		{NULL}
	};
	while(--childrenToGo != 0) {
		++pd->i; // advance to next argument/child
		if(TOKC.type == JSMN_ARRAY) { // if argument is a block
			++pd->i; // advance to opstring
			if(TOKC.type == JSMN_ARRAY) { // if the argument really is a substack rather than just a block
				--pd->i; // step back to array of blocks
				return childrenToGo;
			}
			tmpBlock.hash = HASH(); // hash opstring
			parseBlockArgs(pd, tokens[pd->i - 1].size, level+1); // parse the arguments
		}
		else if (TOKC.type == JSMN_STRING) { // argument is a string
			tmpBlock.hash = pd->noop_hash;
			tmpValue.type = STRING;
			tokcext(tmpValue.data.string); // parse string into Value
			utarray_push_back(pd->indicesBuffer, &utarray_len(pd->valueBuffer)); // record index of Value that this Block will refence
			utarray_push_back(pd->valueBuffer, &tmpValue); // store value in persistent memory
		}
		else { // else argument is a primitive
			tmpBlock.hash = pd->noop_hash;
			tmpValue = strnToValue(gjson(TOKC), tokclen()); // parse value from JSON
			utarray_push_back(pd->indicesBuffer, &utarray_len(pd->valueBuffer)); // record index of Value that this Block will refence
			utarray_push_back(pd->valueBuffer, &tmpValue); // store value in persistent memory
		}
		utarray_push_back(pd->blockBuffer, &tmpBlock); // append block in buffer to script
	}
	return 0;
}

/* Parses a stack of blocks, using recursion when it encounters a substack.
	 pd->i should point to the token just before the first stack block. */
static void parseStack(struct parsingData_t *const pd, uint16 stackBlocksToGo) {
	unsigned int i, indexForLastStackBlock, indexOfNextStackBlock;
	bool isFirstBlockOfStack;
	Block **subStacks;
	Block tmpBlock = {
		0,
		0,
		{NULL}
	};

	++pd->i; // advance to first stack block
	isFirstBlockOfStack = true;
	do {
		++pd->i; // advance to opstring
		tmpBlock.hash = HASH(); // hash opstring and store in block in buffer
		i = parseBlockArgs(pd, tokens[pd->i - 1].size, 1); // parse arguments

		if(i != 0) { // if the block has substacks
			++i; // increment number of substacks by one to make room for the substack following the entire block
			subStacks = malloc(sizeof(Block*)*i);
			tmpBlock.p.subStacks = subStacks;
			utarray_push_back(pd->indicesBuffer, &i); // store amount of substacks here
		}
		else {
			++pd->i; // advance to next block (or script [xpos, ypos, [...]]) or key if this is the last block)
			indexForLastStackBlock = utarray_len(pd->indicesBuffer);
			indexOfNextStackBlock = utarray_len(pd->blockBuffer)+1;
			utarray_push_back(pd->indicesBuffer, &indexOfNextStackBlock); // record the index where the next stack block will appear
		}

		utarray_push_back(pd->blockBuffer, &tmpBlock); // append block from temporary buffer to persistent block array

		if(i != 0) {
			if(i == 3) { // if it is a doIfElse block
				
			}
			else if(tmpBlock.hash == pd->doIf_hash) { // if it is a doIf block
				utarray_push_back(pd->indicesBuffer, &utarray_len(pd->blockBuffer)); // record index that the first block of the substack inside the C will occur in
				indexForLastStackBlock = utarray_len(pd->indicesBuffer);
				utarray_extend_back(pd->indicesBuffer); // reserve element that will store the index of the first block after the C
				parseStack(pd, TOKC.size); // parse stack inside C
				utarray_push_back(pd->indicesBuffer, &utarray_len(pd->blockBuffer)); // link last block inside C to first block outside C
				*utarray_eltptr(pd->indicesBuffer, indexForLastStackBlock) = *utarray_back(pd->indicesBuffer);
				++pd->i; // advance to stack after C
			}
			else { // it is a looping block

			}
			for(; --i != 0;) { // parse substacks, if any
				utarray_push_back(pd->indicesBuffer, &utarray_len(pd->blockBuffer)); // record index that the first Block of the substack will be in
				parseStack(pd, TOKC.size);
				++pd->i; // advance to next substack (array of blocks), or to the next block if this is the last substack
			}
			utarray_push_back(pd->indicesBuffer, &utarray_len(pd->blockBuffer)); // store the index of the first block of the stack following this block
			isFirstBlockOfStack = true;
		} // continue as normal
	} while (--stackBlocksToGo != 0);
	*utarray_back(pd->indicesBuffer) = 0; // end of stack, so set this index to 0 to say that there are no more blocks
}

static void parseScripts(struct parsingData_t *const pd) {
	puts("scripts");
	uint16 scriptsToGo, stackBlocksToGo;
	ubyte j, k;
	ThreadContext tmpThreadContext = createThreadContext(pd->currentContext, NULL);

	Block *block;
	Value *valueBuffer;
	const unsigned int *index;

	++pd->i; // advance to array of scripts
	scriptsToGo = TOKC.size;
	++pd->i; // advance to first script
	do {
		pd->i += 3; // advanced past script position to script (array of blocks)
		stackBlocksToGo = TOKC.size-1;
		pd->i += 2; // advance to first block ([opstring, arguments...]), then to its opstring
		if(tokceq("whenGreenFlag")) { // only if it is a hat block (just green flag for now)
			parseStack(pd, stackBlocksToGo);

			utarray_extract(pd->blockBuffer, block);
			tmpThreadContext.nextBlock = block;
			utarray_extract(pd->valueBuffer, valueBuffer);
			utarray_push_back(pd->valueBuffers, &valueBuffer);

			index = NULL;
			// calculate pointers using indicesBuffer
			for(stackBlocksToGo = 0; stackBlocksToGo < utarray_len(pd->blockBuffer); ++stackBlocksToGo) {
				if(block->level == 0) {
					index = (unsigned int*)utarray_next(pd->indicesBuffer, index);
					if(*index == 0)
						block->p.next = NULL;
					else if(block->p.subStacks != NULL) {
						k = *index;
						for(j = 0; j < k; ++j) {
							index = (unsigned int*)utarray_next(pd->indicesBuffer, index);
							block->p.subStacks[j] = (Block*)tmpThreadContext.nextBlock + *index;
						}
					}
					else {
						block->p.next = (Block*)tmpThreadContext.nextBlock + *index;
					}
				}
				else if(block->hash == pd->noop_hash) {
					index = (unsigned int*)utarray_next(pd->indicesBuffer, index);
					block->p.value = valueBuffer + *index;
				}
				++block;
			}

			utarray_push_back(pd->greenFlagScripts, &tmpThreadContext); // add script to list of green flag scripts

			utarray_clear(pd->blockBuffer);
			utarray_clear(pd->valueBuffer);
			utarray_clear(pd->indicesBuffer);
		}
		else {
			pd->i -= 5; // go back to script ([x_pos, y_pos, [blocks ...]])
			SKIP(); // skip the script
		}
	} while (--scriptsToGo != 0);
	pd->i++;
}

/*static void parseScripts(struct parsingData_t *const pd) {
	puts("scripts");
	uint16 scriptsToGo, stackBlocksToGo;
	unsigned int i, indexForLastStackBlock;
	bool isFirstBlockOfStack;
	Block tmpBlock = {
		0,
		0,
		{NULL}
	};
	ThreadContext tmpThreadContext = createThreadContext(pd->currentContext, NULL);

	++pd->i; // advance to array of scripts
	scriptsToGo = TOKC.size;
	++pd->i; // advance to script x position
	do {
		pd->i += 3; // advanced past script position to script (array of blocks)
		stackBlocksToGo = TOKC.size-1;
		++pd->i; // advance to first stack block ([opstring, arguments...])
		++pd->i; // advance to opstring
		if(tokceq("whenGreenFlag")) { // only if it is a hat block (just green flag for now)
			--pd->i; // return to first stack (hat) block ([opstring, args...])
			SKIP(); // skip to first stack block
			isFirstBlockOfStack = true;
			do {
				++pd->i; // advance to opstring
				tmpBlock.hash = HASH(); // hash opstring and store in block in buffer
				if(parseBlockArgs(pd, tokens[pd->i - 1].size, 1) != 0) { // parse arguments, and check if the block has substacks
					;
				}
				++pd->i; // advance to next block (or script [xpos, ypos, [...]]) or key if this is the last block)

				if(isFirstBlockOfStack)
					isFirstBlockOfStack = false;
				else
					*utarray_eltptr(pd->indicesBuffer, indexForLastStackBlock) = indexForLastStackBlock + 1;
				indexForLastStackBlock = utarray_len(pd->indicesBuffer);
				utarray_extend_back(pd->indicesBuffer); // reserve element for this stack block

				utarray_push_back(pd->blockBuffer, &tmpBlock); // append block from temporary buffer to persistent block array
			} while (--stackBlocksToGo != 0);
			*utarray_back(pd->indicesBuffer) = 0; // end of stack, so set this index to 0

			Block *block;
			Value *valueBuffer;
			utarray_extract(pd->blockBuffer, block);
			tmpThreadContext.nextBlock = block;
			utarray_extract(pd->valueBuffer, valueBuffer);
			utarray_push_back(pd->valueBuffers, &valueBuffer);

			const unsigned int *index = NULL;
			// calculate pointers using indicesBuffer
			for(i = 0; i < utarray_len(pd->blockBuffer); ++i) {
				index = (unsigned int*)utarray_next(pd->indicesBuffer, index);
				if(block->level == 0) {
					if(*index == 0)
						block->p.next = NULL;
					else
						block->p.next = (Block*)tmpThreadContext.nextBlock + *index;
				}
				else if(block->hash == pd->noop_hash) {
					block->p.value = valueBuffer + *index;
				}
				++block;
			}

			utarray_push_back(pd->greenFlagScripts, &tmpThreadContext); // add script to list of green flag scripts

			utarray_clear(pd->blockBuffer);
			utarray_clear(pd->valueBuffer);
			utarray_clear(pd->indicesBuffer);
		}
		else {
			pd->i -= 5; // go back to script ([x_pos, y_pos, [blocks ...]])
			SKIP(); // skip the script
		}
	} while (--scriptsToGo != 0);
	pd->i++;
	}*/

#undef json
#undef jsonSize
#undef tokens
#undef nTokens

#undef gjson
#undef TOKC
#define gjson(tok) (pd.json+(tok).start)
#define TOKC (pd.tokens[pd.i])

int main(void) {
	struct parsingData_t pd = {
		NULL,
		0,

		NULL,
		0,
		1,

		NULL,
		0,
		0,


		NULL,
		NULL,
	};

	pd.jsonSize = loadFile("project_test.json", &pd.json);
	if(pd.jsonSize == 0)
		return 1;

	tokenize(&pd);
	if(pd.nTokens < 0) {
		free(pd.json);
		return 1;
	}

	loadBlockHashFunc(&pd);
	pd.noop_hash = (blockhash)cmph_search(pd.mph, "noop", (cmph_uint32)4);
	pd.doIf_hash = (blockhash)cmph_search(pd.mph, "doIf", (cmph_uint32)4);

	utarray_new(pd.blockBuffer, &Block_icd);
	utarray_new(pd.valueBuffer, &Value_icd);
	utarray_new(pd.indicesBuffer, &unsigned_int_icd);

	utarray_new(pd.greenFlagScripts, &ThreadContext_icd);

	utarray_new(pd.valueBuffers, &pointer_icd);

	// parse the file with the tokens
	/* For the Scratch JSON files we can assume that the whole thing is wrapped in an object,
		 and that everything inside that is key-value pairs, where the key is a single string.  */
	uint16 i = pd.tokens[0].size;

	SpriteContext *stageContext = malloc(sizeof(SpriteContext));
	initializeSpriteContext(stageContext);

	do {
		if(tokceq("variables")) {
			pd.currentContext = stageContext;
			parseVariables(&pd);
		}
		else if(tokceq("lists")) {
			pd.currentContext = stageContext;
			parseLists(&pd);
		}
		else if(tokceq("scripts")) {
			pd.currentContext = stageContext;
			parseScripts(&pd);
		}
		else if(tokceq("children")) {
			puts("children");
			skip(&pd);
		}
		else // key isn't significant
			skip(&pd);
	} while(--i != 0);

	/* This for loop prints out the array of tokens for debugging help */
	/*for(i = 0; i < pd.nTokens; ++i) {
		printf("%5i: { ", i);
		switch(pd.tokens[i].type) {
		case JSMN_PRIMITIVE: printf("PRIMITIVE"); break;
		case JSMN_OBJECT: printf("OBJECT"); break;
		case JSMN_ARRAY: printf("ARRAY"); break;
		case JSMN_STRING: printf("STRING"); break;
		case JSMN_UNDEFINED: printf("UNDEFINED");
		}
		printf(", %i, %i, %i }\n", pd.tokens[i].start, pd.tokens[i].end, pd.tokens[i].size);
		}*/

	utarray_free(pd.blockBuffer);
	utarray_free(pd.valueBuffer);
	utarray_free(pd.indicesBuffer);

	/* give the runtime the scripts to run on green flag pressed */
	ThreadContext *greenFlagContexts;
	uint16 nContexts = utarray_len(pd.greenFlagScripts);
	utarray_finalize(pd.greenFlagScripts, greenFlagContexts);
	setContextsForGreenFlags(greenFlagContexts, nContexts);

	nValueBuffers = utarray_len(pd.valueBuffers);
	utarray_finalize(pd.valueBuffers, valueBuffers);

	cmph_destroy(pd.mph);
	free(pd.json);
	free(pd.tokens);
	puts("done parsing.");

	puts("starting");
	restartThreadsForGreenFlag();
	puts("running");
	stepThreads();
	puts("done.");

	return 0;
}
