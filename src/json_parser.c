/**
	Project JSON Reader
			json_reader.c

	Parses the project.json of a Scratch project and builds it internally.
	Currently it loads the entire JSON into memory, tokenizes it all with JSMN, and then
	goes through the tokens to build SpriteContexts, ThreadContexts, Block stacks, etc.

	The goal is to not store anything in static memory that doesn't live thoughout the
	entirety of running a project.
**/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iconv.h>
#include <errno.h>

#include "jsmn/jsmn.h"
#include <cmph.h>
#include "ut/dynarray.h"

#include "types/primitives.h"
#include "types/value.h"
#include "types/block.h"
#include "types/thread.h"
#include "types/sprite.h"

#include "blockhash/typestable.c"

#include "value.h"
#include "variables.h"
#include "runtime.h"

struct parsingData_t {
	char *json;
	long jsonSize;

	jsmntok_t *tokens;
	long long int nTokens;
	long unsigned int i;

	cmph_t *mph;
	blockhash noop_hash; // hash "noop" once, use many times
	blockhash doIf_hash;

	iconv_t charCd;
	dynarray *charBuffer1; // buffers to temporarily store strings
	dynarray *charBuffer2;

	dynarray *blockBuffer;
	dynarray *valueBuffer;
	dynarray *indicesBuffer; // used by blocks in the blockBuffer to store indices of blocks or values that they reference
	dynarray *valueBuffers; // temporarily store pointers to all of the memory chunks of Values so that they can be freed.
	
	SpriteContext *currentContext;
	dynarray *threads;
	dynarray *greenFlagThreadIndices;
};

// macros for convenience
#define json (pd->json)
#define jsonSize (pd->jsonSize)
#define tokens (pd->tokens)
#define nTokens (pd->nTokens)

// calculate pointer to token in the JSON text.
#define gjson(tok) (json+(tok).start)

// get the current token
#define TOKC (tokens[pd->i])
// calculate length of the given token
#define toklen(tok) ((tok).end-(tok).start)
// calculate length of the current token
#define tokclen() (toklen(TOKC))
// check if the current token is equal to the given string.
#define tokceq(str) (strncmp(str, gjson(TOKC), tokclen()) == 0)
// extract the text pointed to by the current token into dst and using tmpLen
#define tokcext(dst) {																									\
		parseString(pd, gjson(TOKC), tokclen(), pd->charBuffer1);						\
		dynarray_extract(pd->charBuffer1, (void**)&dst);										\
		/*if(dst == NULL)*/																									\
		/*	puts("[FATAL]Could not malloc dst string in tokcext");*/				\
	}

#define hash(key, keylen) ((blockhash)(cmph_search(pd->mph, key, keylen)))

#define initializeSpriteContext(c) {															\
		c->variables = NULL;																					\
		c->lists = NULL;																							\
		c->xpos = c->ypos = c->layer = c->costumeNumber = 0;					\
		c->direction = 90; c->size = c->volume = 100; c->tempo = 60;	\
		c->effects.color = c->effects.brightness = c->effects.ghost		\
			= c->effects.pixelate = c->effects.mosaic										\
			= c->effects.fisheye = c->effects.whirl											\
			= 0;																												\
	}

static long loadFile(const char *const path, char **const output) {
	FILE *stream = fopen(path, "rb");
	if(stream == NULL) {
		printf("ERROR\n\tThe file `%s` could not be opened\n", path);
		fclose(stream);
		return 0;
	}
	fseek(stream, 0, SEEK_END);
	long sizeofFile = ftell(stream);
	*output = malloc(sizeofFile);
	rewind(stream);
	fread(*output, sizeof(char), sizeofFile, stream);
	fclose(stream);
	return sizeofFile;
}

static inline void tokenize(struct parsingData_t *const pd) {
	jsmn_parser parser;

	// tokenize the file
#define ERROR(s) {puts("[FATAL]"s); return;}
	jsmn_init(&parser);
	nTokens = jsmn_parse(&parser, json, jsonSize, NULL, 0);
	if(nTokens == JSMN_ERROR_INVAL)
		ERROR("JSMN_ERROR_INVAL")
	else if(nTokens == JSMN_ERROR_PART)
		ERROR("JSMN_ERROR_PART")
	tokens = malloc(nTokens*sizeof(jsmntok_t));

	jsmn_init(&parser);
	nTokens = jsmn_parse(&parser, json, jsonSize, tokens, nTokens);
	if(nTokens == JSMN_ERROR_INVAL)
		ERROR("JSMN_ERROR_INVAL")
	else if(nTokens == JSMN_ERROR_PART)
		ERROR("JSMN_ERROR_PART")
	else if(nTokens == JSMN_ERROR_NOMEM)
		ERROR("JSMN_ERROR_NOMEM")
#undef ERROR
}

/* load minimum perfect hash file generated by cmph */
static inline void loadBlockHashFunc(struct parsingData_t *const pd) {
	FILE *stream = fopen("blockops.mphf", "r");
	if(stream == NULL)
		puts("[FATAL]Could not load block hash function");
	pd->mph = cmph_load(stream);
	fclose(stream);
}

/* Skips the current token and it's children. Because JSMN makes values children of their
	 keys, calling this when pd->i points to a key will skip the whole key-value pair. */
static void skip(struct parsingData_t *const pd) {
	long unsigned int tokensToSkip = 1;
	do {
		tokensToSkip += TOKC.size; // add child tokens to tokensToSkip
		++pd->i; // skip token
	} while(--tokensToSkip != 0);
}

#define SKIP() skip(pd);

/* Parses the string starting at str of length len into the given dynarray.
	 If the string needs to be kept after parsing, then a simple dynarray_extract will work. */
static char* parseString(struct parsingData_t *const pd, const char *str, const unsigned len, dynarray *const charBuffer) {
	dynarray_clear(charBuffer);
	dynarray_ensure_size(charBuffer, len);
	const char *const end = str+len;
	char c; uint32 w;

	char *inbuf, *outbuf;
	size_t inbytesleft, outbytesleft;

	for(; str != end; ++str) {
		c = *str;
		if(c == '\\') {
			++str;
			c = *str;
			switch(c) {
			case 'b': c = '\b'; break;
			case 'f': c = '\f'; break;
			case 'n': c = '\n'; break;
			case 'r': c = '\r'; break;
			case 't': c = '\t'; break;
			case 'u':
				++str;
				inbuf = (char*)str+4; // ugly variable reuse
				w = (uint32)strtol(str, &inbuf, 16);
				if(w < 128) { // if the codepoint is within the ASCII range
					c = (char)w;
					str+=3;
					break;
				}
				else {
					dynarray_reserve(charBuffer, 4);

					inbuf = (char*)&w; outbuf = charBuffer->d + charBuffer->i;
					inbytesleft = 4; outbytesleft = 4;
					if(iconv(pd->charCd, &inbuf, &inbytesleft, &outbuf, &outbytesleft) == (size_t)-1) {
						puts("[WARNING]Could not convert unicode codepoint to UTF-8");
						switch(errno) {
						case E2BIG: puts("\terrno = E2BIG"); break;
						case EILSEQ: puts("\terrno = EILSEQ"); break;
						case EINVAL: puts("\terrno = EINVAL"); break;
						}
					}

					charBuffer->i += 4 - outbytesleft;
					str += 3;
					continue;
				}
			}
		}
		dynarray_push_back(charBuffer, &c);
	}
	dynarray_extend_back(charBuffer); // append a terminator to the string
	return NULL;
}

static inline blockhash _HASH(struct parsingData_t *const pd) {
	parseString(pd, gjson(TOKC), tokclen(), pd->charBuffer1);
	return hash(pd->charBuffer1->d, pd->charBuffer1->i-1);
}
#define HASH() (_HASH(pd))

static void parseVariables(struct parsingData_t *const pd) {
	uint16 elementsToGo, propertiesToGo;
	const char *name;
	puts("variables");

	++pd->i; // advance to array
	elementsToGo = TOKC.size; // number of variable objects to parse
	
	do { // for each variable object
		++pd->i; // advance to variable object
		propertiesToGo = TOKC.size;
		do { // for each property
			++pd->i; // advance to key
			if(tokceq("name")) {
				++pd->i; // advance to value
				tokcext(name);
			}
			else if(tokceq("value")) {
				++pd->i; // advance to value
				parseString(pd, gjson(TOKC), tokclen(), pd->charBuffer2);
			}
			else
				++pd->i;
		} while(--propertiesToGo != 0);
		createVariable(&pd->currentContext->variables, name, strnToValue(pd->charBuffer2->d, pd->charBuffer2->i-1));
	} while(--elementsToGo != 0);
	++pd->i; // advance from last property
}

static void parseLists(struct parsingData_t *const pd) {
	uint16 elementsToGo, propertiesToGo;
	const jsmntok_t *valueToken;
	const char *name;
	puts("lists");

	++pd->i; // advance to array
	elementsToGo = TOKC.size; // number of list objects to parse

	do { // for each list object
		++pd->i; // advance to list object
		propertiesToGo = TOKC.size;
		do { // for each property
			++pd->i; // advance to key
			if(tokceq("listName")) {
				++pd->i; // advance to value
				tokcext(name);
			}
			else if(tokceq("contents")) {
				valueToken = tokens + ++pd->i;
				pd->i += TOKC.size;
			}
			else
				++pd->i; // advance to value
		} while(--propertiesToGo != 0);
		List* list = createList(&pd->currentContext->lists, name, NULL, 0);
		Value value;
		for(propertiesToGo = valueToken->size; propertiesToGo != 0; --propertiesToGo) {
			++valueToken;
			parseString(pd, gjson(*valueToken), toklen(*valueToken), pd->charBuffer2);
			value = strnToValue(pd->charBuffer2->d, pd->charBuffer2->i-1);
			listAppend(list, &value);
			if(value.type == STRING) free(value.data.string);
		}
	} while(--elementsToGo != 0);
	++pd->i; // advance from last property
}

/* Parses arguments to a block, using recursion when one of the arguments is another block.
   pd.i should be the index of the opstring of the current block.
   Returns number of substacks left to parse, and leaves pd.i pointing to the substack (array of blocks),
   or 0 if there are no substacks, and leaves pd.i pointing to the last argument (the last token parsed). */
static void parseBlockArgs(struct parsingData_t *const pd, uint16 childrenToGo, const ubyte level) {
	Value tmpValue;
	Block tmpBlock = {
		0,
		level,
		{NULL}
	};
	while(--childrenToGo != 0) {
		++pd->i; // advance to next argument/child
		if(TOKC.type == JSMN_ARRAY) { // if argument is a block
			++pd->i; // advance to opstring
			tmpBlock.hash = HASH(); // hash opstring
			parseBlockArgs(pd, tokens[pd->i - 1].size, level+1); // parse the arguments
		}
		else if (TOKC.type == JSMN_STRING) { // argument is a string
			tmpBlock.hash = pd->noop_hash;
			tmpValue.type = STRING;
			tokcext(tmpValue.data.string); // parse string into Value
			dynarray_push_back(pd->indicesBuffer, &dynarray_len(pd->valueBuffer)); // record index of Value that this Block will reference
			dynarray_push_back(pd->valueBuffer, &tmpValue); // store value in persistent memory
		}
		else { // else argument is a primitive
			tmpBlock.hash = pd->noop_hash;
			tmpValue = strnToValue(gjson(TOKC), tokclen()); // parse value from JSON (assume characters are within ASCII range)
			dynarray_push_back(pd->indicesBuffer, &dynarray_len(pd->valueBuffer)); // record index of Value that this Block will reference
			dynarray_push_back(pd->valueBuffer, &tmpValue); // store value in persistent memory
		}
		dynarray_push_back(pd->blockBuffer, &tmpBlock); // append block in buffer to script
	}
}

/* Parses a stack of blocks, using recursion when it encounters a substack.
	 pd->i should point to the token just before the first stack block.
	 Returns false if there is no substack, and leaves pd->i pointing to the last token parsed */
static bool parseStack(struct parsingData_t *const pd, uint16 stackBlocksToGo, const unsigned int indexForPreviousBlock) {
	if(stackBlocksToGo == 0)
		return false;
	static unsigned int i = 0;
	unsigned int indexForLastBlock;
	bool isFirstBlock;
	Block tmpBlock = {
		0,
		0,
		{NULL}
	};

	if(indexForPreviousBlock != 0) {
		indexForLastBlock = indexForPreviousBlock;
		isFirstBlock = false;
	}
	else
		isFirstBlock = true;

	do {
		pd->i += 2; // advance to next block's opstring
		tmpBlock.hash = HASH(); // hash opstring and store in block in buffer

		// link previous stack block to this stack block
		if(!isFirstBlock)
			*(unsigned int*)dynarray_eltptr(pd->indicesBuffer, indexForLastBlock) = dynarray_len(pd->blockBuffer); // point the previous stack block to this stack block (aka following stack)

		// handle linking blocks properly
		switch(blockTypesTable[tmpBlock.hash]) {

		default: // no substacks
			parseBlockArgs(pd, tokens[pd->i - 1].size, 1); // parse all arguments

			indexForLastBlock = dynarray_len(pd->indicesBuffer); // remember index for this stack block
			i = 0;
			dynarray_push_back(pd->indicesBuffer, &i); // link this stack block to 0 (NULL). it will be linked to the next stack block if there is one

			dynarray_push_back(pd->blockBuffer, &tmpBlock); // append block from temporary buffer to persistent block array
			break;

		case BLOCK_TYPE_C: // 2 substacks: inner and following
			parseBlockArgs(pd, tokens[pd->i - 1].size - 1, 1); // parse arguments, but leave the last one (the substack)

			i = 2;
			dynarray_push_back(pd->indicesBuffer, &i); // store amount of substacks here
			indexForLastBlock = dynarray_len(pd->indicesBuffer);
			i = 0;
			dynarray_push_back(pd->indicesBuffer, &i); // set pointer to the inner stack to 0 (NULL)
			dynarray_push_back(pd->indicesBuffer, &i); // set pointer to following stack to 0 (NULL)

			tmpBlock.p.subStacks = malloc(sizeof(Block*)*2); // reserve room for the substacks
			dynarray_push_back(pd->blockBuffer, &tmpBlock); // append block from temporary buffer to persistent block array

			++pd->i; // advance to array of stack blocks, or 'null' if the slot is empty
			parseStack(pd, TOKC.size, indexForLastBlock); // parse stack inside C
			++indexForLastBlock;
			break;

		case BLOCK_TYPE_CF: // 1 substack: one inner and no following
			// no CF blocks have arguments currently
			//parseBlockArgs(pd, tokens[pd->i - 1].size - 1, 1); // parse arguments, but leave the last one (the substack)

			i = 1;
			dynarray_push_back(pd->indicesBuffer, &i); // store amount of substacks here
			indexForLastBlock = dynarray_len(pd->indicesBuffer);
			i = 0;
			dynarray_push_back(pd->indicesBuffer, &i); // set pointer to the inner stack to 0 (NULL)

			tmpBlock.p.subStacks = malloc(sizeof(Block*)); // reserve room for the substacks
			dynarray_push_back(pd->blockBuffer, &tmpBlock); // append block from temporary buffer to persistent block array

			++pd->i; // advance to array of stack blocks, or 'null' if the slot is empty
			parseStack(pd, TOKC.size, indexForLastBlock); // parse stack inside C
			break;

		case BLOCK_TYPE_E: // 3 substacks: 2 inner and 1 following
			parseBlockArgs(pd, tokens[pd->i - 1].size - 2, 1); // parse arguments, but leave the last two (the substacks)

			i = 3;
			dynarray_push_back(pd->indicesBuffer, &i); // store amount of substacks here
			indexForLastBlock = dynarray_len(pd->indicesBuffer);
			i = 0;
			dynarray_push_back(pd->indicesBuffer, &i); // set pointer to the first inner stack to 0 (NULL)
			dynarray_push_back(pd->indicesBuffer, &i); // set pointer to the second inner stack to 0 (NULL)
			dynarray_push_back(pd->indicesBuffer, &i); // set pointer to following stack to 0 (NULL)

			tmpBlock.p.subStacks = malloc(sizeof(Block*)*3); // reserve room for the substacks
			dynarray_push_back(pd->blockBuffer, &tmpBlock); // append block from temporary buffer to persistent block array

			++pd->i; // advance to first array of stack blocks, or 'null' if the slot is empty
			parseStack(pd, TOKC.size, indexForLastBlock); // parse first stack inside E
			++indexForLastBlock;
			++pd->i; // advance to second array of stack blocks, or 'null' if the slot is empty
			parseStack(pd, TOKC.size, indexForLastBlock); // parse second stack inside E
			++indexForLastBlock;
			break;

		}
		tmpBlock.p.subStacks = NULL;
		isFirstBlock = false;
	} while (--stackBlocksToGo != 0);
	return true;
}

static void parseScripts(struct parsingData_t *const pd) {
	puts("scripts");
	uint16 scriptsToGo, stackBlocksToGo;
	ubyte j, k;
	ThreadLink tmpThread = {{0}, pd->currentContext, NULL}; // TODO: put all threads in one big array

	Block *block;
	Value *valueBuffer;
	const unsigned int *index;

	++pd->i; // advance to array of scripts
	scriptsToGo = TOKC.size;
	++pd->i; // advance to first script
	do {
		pd->i += 3; // advanced past script position to script (array of blocks)
		stackBlocksToGo = TOKC.size-1;
		pd->i += 2; // advance to first block ([opstring, arguments...]), then to its opstring

		if(tokceq("whenGreenFlag")) { // only if it is a hat block (just green flag for now)
			if(parseStack(pd, stackBlocksToGo, 0)) {
				dynarray_extract(pd->blockBuffer, (void**)&block);
				tmpThread.thread = createThreadContext(block);

				dynarray_extract(pd->valueBuffer, (void**)&valueBuffer);
				dynarray_push_back(pd->valueBuffers, &valueBuffer);

				index = NULL;
				// calculate pointers using indicesBuffer TODO: repetative code, refractor?
				for(stackBlocksToGo = 0; stackBlocksToGo < dynarray_len(pd->blockBuffer); ++stackBlocksToGo) {
					if(block->hash == pd->noop_hash) {
						index = (unsigned int*)dynarray_next(pd->indicesBuffer, (void*)index);
						block->p.value = valueBuffer + *index;
					}
					else if(block->level == 0) {
						index = (unsigned int*)dynarray_next(pd->indicesBuffer, (void*)index);
						if(block->p.subStacks == NULL) {
							if(*index == 0)
								block->p.next = NULL;
							else
								block->p.next = (Block*)tmpThread.thread.startingBlock + *index;
						}
						else {
							k = *index;
							for(j = 0; j < k; ++j) {
								index = (unsigned int*)dynarray_next(pd->indicesBuffer, (void*)index);
								if(*index == 0)
									block->p.subStacks[j] = NULL;
								else
									block->p.subStacks[j] = (Block*)tmpThread.thread.startingBlock + *index;
							}
						}
					}
					++block;
				}

				dynarray_push_back(pd->greenFlagThreadIndices, &dynarray_len(pd->threads)); // add script to list of green flag scripts
				dynarray_push_back(pd->threads, &tmpThread); // add script to array of scripts

				dynarray_clear(pd->blockBuffer);
				dynarray_clear(pd->valueBuffer);
				dynarray_clear(pd->indicesBuffer);

		 		++pd->i; // advance to next block (or script [xpos, ypos, [...]]) or key if this is the last block)
			}
		}
		else {
			pd->i -= 5; // go back to script ([x_pos, y_pos, [blocks ...]])
			SKIP(); // skip the script
		}
	} while (--scriptsToGo != 0);
	pd->i++;
}

static void loadHats(struct parsingData_t *const pd, ThreadLink *const threads) {
	unsigned int i = 0;
	ThreadLink **hats = malloc(i*sizeof(ThreadLink**));
	for(i = 0; i < dynarray_len(pd->greenFlagThreadIndices); ++i)
		hats[i] = threads+i;
	setGreenFlagThreads(hats, i);
}

#undef json
#undef jsonSize
#undef tokens
#undef nTokens

#undef gjson
#undef TOKC
#define gjson(tok) (pd.json+(tok).start)
#define TOKC (pd.tokens[pd.i])

int main(void) {
	/* initialize all resources used during loading */
	struct parsingData_t pd = {
		NULL,
		0,

		NULL,
		0,
		1,

		NULL,
		0,
		0,

		0,
		NULL,
		NULL,

		NULL,
		NULL,
		NULL,
		NULL,

		NULL,
		NULL,
		NULL,
	};

	pd.jsonSize = loadFile("project_test.json", &pd.json);
	if(pd.jsonSize == 0)
		return 1;

	tokenize(&pd);
	if(pd.nTokens < 0) {
		free(pd.json);
		return 1;
	}

	loadBlockHashFunc(&pd);
	pd.noop_hash = (blockhash)cmph_search(pd.mph, "noop", (cmph_uint32)4);
	pd.doIf_hash = (blockhash)cmph_search(pd.mph, "doIf", (cmph_uint32)4);

	pd.charCd = iconv_open("UTF-8", "UTF-32LE"); // LE for little-endian
	if(pd.charCd == (iconv_t)-1) puts("[WARNING]Could not create encoding conversion descriptor.");
	dynarray_new(pd.charBuffer1, sizeof(char));
	dynarray_new(pd.charBuffer2, sizeof(char));

	dynarray_new(pd.blockBuffer, sizeof(Block));
	dynarray_new(pd.valueBuffer, sizeof(Value));
	dynarray_new(pd.indicesBuffer, sizeof(unsigned int));

	dynarray_new(pd.threads, sizeof(ThreadLink));
	dynarray_new(pd.greenFlagThreadIndices, sizeof(unsigned int));

	dynarray_new(pd.valueBuffers, sizeof(Value*));

	/* parse
		 For the Scratch JSON files we can assume that the whole thing is wrapped in an object,
		 and that everything inside that is key-value pairs, where the key is a single string.  */
	uint16 i = pd.tokens[0].size;

	SpriteContext *stageContext = malloc(sizeof(SpriteContext));
	initializeSpriteContext(stageContext);

	do {
		if(tokceq("variables")) {
			pd.currentContext = stageContext;
			parseVariables(&pd);
		}
		else if(tokceq("lists")) {
			pd.currentContext = stageContext;
			parseLists(&pd);
		}
		else if(tokceq("scripts")) {
			pd.currentContext = stageContext;
			parseScripts(&pd);
		}
		else if(tokceq("children")) {
			puts("children");
			skip(&pd);
		}
		else // key isn't significant
			skip(&pd);
	} while(--i != 0);

	/* This for loop prints out the array of tokens for debugging help */
	/*for(i = 0; i < pd.nTokens; ++i) {
		printf("%5i: { ", i);
		switch(pd.tokens[i].type) {
		case JSMN_PRIMITIVE: printf("PRIMITIVE"); break;
		case JSMN_OBJECT: printf("OBJECT"); break;
		case JSMN_ARRAY: printf("ARRAY"); break;
		case JSMN_STRING: printf("STRING"); break;
		case JSMN_UNDEFINED: printf("UNDEFINED");
		}
		printf(", %i, %i, %i }\n", pd.tokens[i].start, pd.tokens[i].end, pd.tokens[i].size);
		}*/

	/* free resources used during parsing */
	dynarray_free(pd.charBuffer1);
	dynarray_free(pd.charBuffer2);
	dynarray_free(pd.blockBuffer);
	dynarray_free(pd.valueBuffer);
	dynarray_free(pd.indicesBuffer);
	cmph_destroy(pd.mph);
	free(pd.json);
	free(pd.tokens);
	puts("done parsing.");

	/* retrieve what was parsed that needs to be kept */
	ThreadLink *threads;
	dynarray_finalize(pd.threads, (void**)&threads);

	static unsigned int nValueBuffers;
	static const Value *valueBuffers; // store pointers to all of the memory chunks of Values so that they can be freed.
	nValueBuffers = dynarray_len(pd.valueBuffers);
	dynarray_finalize(pd.valueBuffers, (void**)&valueBuffers);

	/* load what was parsed into the runtime */
	pd.currentContext->threads = threads;
	loadHats(&pd, threads);
	dynarray_free(pd.greenFlagThreadIndices);

	puts("starting");
	restartGreenFlagThreads();
	puts("running");
	stepThreads();
	puts("done.");

	return 0;
}
