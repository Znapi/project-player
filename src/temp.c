/**
	Project JSON Reader
			json_reader.c

	Parses the project.json of a Scratch project and builds it internally.
	Currently it loads the entire JSON into memory, tokenizes it all with JSMN, and then
	goes through the tokens to build SpriteContexts, ThreadContexts, Block stacks, etc.
**/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "project_path.h"
#include "jsmn/jsmn.h"
#include <cmph.h>
#include "ut/utarray.h"

#include "types/primitives.h"
#include "types/value.h"
#include "types/block.h"
#include "types/thread.h"
#include "types/sprite.h"

#include "value.h"
#include "variables.h"
#include "runtime.h"


struct parsingData_t {
	char *json;
	long jsonSize;

	jsmntok_t *tokens;
	long long int nTokens;
	long unsigned int i;

	cmph_t *mph;


	SpriteContext *spriteContext;
	UT_array *greenFlagScripts;

	Block *blockBuffer;
	Value *valueBuffer;
};

// macros for convenience
#define json (pd->json)
#define jsonSize (pd->jsonSize)
#define tokens (pd->tokens)
#define nTokens (pd->nTokens)

// calculate pointer to token in the JSON text.
#define gjson(tok) (json+(tok).start)

// get the current token
#define TOKC (tokens[pd->i])
// calculate length of the given token
#define toklen(tok) ((tok).end-(tok).start)
// calculate length of the current token
#define TOKCLEN (toklen(TOKC))
// check if the current token is equal to the given string.
#define tokceq(str) (strncmp(str, gjson(TOKC), TOKCLEN) == 0)
// extract the text pointed to by the current token into dst and using tmpLen
#define tokcext(dst) {																									\
		dst = malloc(TOKCLEN);																							\
		if(dst == NULL)																											\
			puts("[FATAL]Could not malloc dst string in tokcext");						\
		memcpy(dst, gjson(TOKC), TOKCLEN*sizeof(char));											\
		dst[TOKCLEN] = '\0';																								\
	}

#define hash(key, keylen) ((blockhash)(cmph_search(pd->mph, key, keylen)))
#define HASH() (hash(gjson(TOKC), TOKCLEN))

static const UT_icd ThreadContext_icd = {sizeof(ThreadContext), NULL, NULL, NULL};

#define initializeSpriteContext(c) {															\
		c->variables = NULL;																					\
		c->lists = NULL;																							\
		c->xpos = c->ypos = c->layer = c->costumeNumber = 0;					\
		c->direction = 90; c->size = c->volume = 100; c->tempo = 60;	\
		c->effects.color = c->effects.brightness = c->effects.ghost		\
			= c->effects.pixelate = c->effects.mosaic										\
			= c->effects.fisheye = c->effects.whirl;										\
	}


static long loadFile(const char *const path, char **const output) {
	FILE *stream = fopen(path, "rb");
	if(stream == NULL) {
		printf("ERROR\n\tThe file `%s` could not be opened\n", path);
		fclose(stream);
		return 0;
	}
	fseek(stream, 0, SEEK_END);
	long sizeofFile = ftell(stream);
	*output = malloc(sizeofFile);
	rewind(stream);
	fread(*output, sizeof(char), sizeofFile, stream);
	fclose(stream);
	return sizeofFile;
}

static inline void tokenize(struct parsingData_t *const pd) {
	jsmn_parser parser;

	// tokenize the file
#define ERROR(s) {puts("[FATAL]"s); return;}
	jsmn_init(&parser);
	nTokens = jsmn_parse(&parser, json, jsonSize, NULL, 0);
	if(nTokens == JSMN_ERROR_INVAL)
		ERROR("JSMN_ERROR_INVAL")
	else if(nTokens == JSMN_ERROR_PART)
		ERROR("JSMN_ERROR_PART")
	tokens = malloc(nTokens*sizeof(jsmntok_t));

	jsmn_init(&parser);
	nTokens = jsmn_parse(&parser, json, jsonSize, tokens, nTokens);
	if(nTokens == JSMN_ERROR_INVAL)
		ERROR("JSMN_ERROR_INVAL")
	else if(nTokens == JSMN_ERROR_PART)
		ERROR("JSMN_ERROR_PART")
	else if(nTokens == JSMN_ERROR_NOMEM)
		ERROR("JSMN_ERROR_NOMEM")
#undef ERROR
}

/* load minimum perfect hash file generated by cmph */
static inline void loadBlockHashFunc(struct parsingData_t *const pd) {
	FILE *stream = fopen(PROJECT_PATH"src/perfect_hashes/blocks.mphf", "r");
	if(stream == NULL)
		puts("[FATAL]Could not load block hash function");
	pd->mph = cmph_load(stream);
	fclose(stream);
}

/* Skips the current token and it's children. Because JSMN makes values children of their
	 keys, calling this when pd->i points to a key will skip the whole key-value pair. */
static void skip(struct parsingData_t *const pd) {
	long unsigned int tokensToSkip = 1;
	do {
		tokensToSkip += TOKC.size; // add child tokens to tokensToSkip
		++pd->i; // skip token
	} while(--tokensToSkip != 0);
}

#define SKIP() skip(pd);
static void parseVariables(struct parsingData_t *const pd) {
	uint16 elementsToGo, propertiesToGo;
	char *name;
	jsmntok_t *valueToken;
	puts("variables");

	++pd->i; // advance to array
	elementsToGo = TOKC.size; // number of variable objects to parse
	
	do { // for each variable object
		++pd->i; // advance to variable object
		propertiesToGo = TOKC.size;
		do { // for each property
			++pd->i; // advance to key
			if(tokceq("name")) {
				++pd->i; // advance to value
				tokcext(name);
			}
			else if(tokceq("value")) {
				++pd->i; // advance to value
				valueToken = tokens+pd->i;
			}
			else
				++pd->i;
		} while(--propertiesToGo != 0);
		createVariable(&pd->spriteContext->variables, name, strnToValue(gjson(*valueToken), toklen(*valueToken)));
	} while(--elementsToGo != 0);
	++pd->i; // advance from last property
}

static void parseLists(struct parsingData_t *const pd) {
	uint16 elementsToGo, propertiesToGo;
	char *name;
	jsmntok_t *valueToken;
	puts("lists");

	++pd->i; // advance to array
	elementsToGo = TOKC.size; // number of list objects to parse

	do { // for each list object
		++pd->i; // advance to list object
		propertiesToGo = TOKC.size;
		do { // for each property
			++pd->i; // advance to key
			if(tokceq("listName")) {
				++pd->i; // advance to value
				tokcext(name);
			}
			else if(tokceq("contents")) {
				valueToken = tokens + ++pd->i;
				pd->i += TOKC.size;
			}
			else
				++pd->i; // advance to value
		} while(--propertiesToGo != 0);
		List* list = createList(&pd->spriteContext->lists, name, NULL, 0);
		for(propertiesToGo = valueToken->size; propertiesToGo != 0; --propertiesToGo) {
			++valueToken;
			listAppend(list, strnToValue(gjson(*valueToken), toklen(*valueToken)));
		}
	} while(--elementsToGo != 0);
	++pd->i; // advance from last property
}

static void parseBlockLevel(struct parsingData_t *const pd) {
	
}

static void parseScripts(struct parsingData_t *const pd) {
	uint16 scriptsToGo, stackBlocksToGo;
	puts("scripts");

	++pd->i; // advance to array of scripts
	scriptsToGo = TOKC.size;
	do {
		++pd->i; // advance to script (array of blocks)
		stackBlocksToGo = TOKC.size-1;

		++pd->i; // advance to first stack block ([opstring, arguments...])
		++pd->i; // advance to opstring
		if(tokceq("whenGreenFlag")) { // only if it is a hat block (just green flag for now)
			do {
				--pd->i;
				SKIP(); // skip to next stack block
			} while (--stackBlocksToGo != 0);
		}
		else {
			pd->i -= 3; // go back to script (array of blocks)
			SKIP(); // skip the script
		}
	} while (--scriptsToGo != 0);
}

#undef json
#undef jsonSize
#undef tokens
#undef nTokens

#undef gjson
#undef TOKC
#define gjson(tok) (pd.json+(tok).start)
#define TOKC (pd.tokens[pd.i])

int main(void) {
	struct parsingData_t pd = {
		NULL,
		0,

		NULL,
		0,
		1,

		NULL,


		NULL,
		NULL,
	};

	pd.jsonSize = loadFile("project3.json", &pd.json);
	if(pd.jsonSize == 0)
		return 1;

	tokenize(&pd);
	if(pd.nTokens < 0) {
		free(pd.json);
		return 1;
	}

	loadBlockHashFunc(&pd);
	utarray_new(pd.greenFlagScripts, &ThreadContext_icd);

	// parse the file with the tokens
	/* For the Scratch JSON files we can assume that the whole thing is wrapped in an object,
		 and that everything inside that is key-value pairs, where the key is a single string.  */
	uint16 i = pd.tokens[0].size;

	SpriteContext *stageContext = malloc(sizeof(SpriteContext));
	initializeSpriteContext(stageContext);

	pd.blockBuffer = malloc(16*sizeof(Block)); // should be more than enough room for most projects
	pd.valueBuffer = malloc(16*sizeof(Block)); // should also be good enough for most combinations of a stack blocks and 15 others in its arguments

	do {
		if(tokceq("variables")) {
			pd.spriteContext = stageContext;
			parseVariables(&pd);
		}
		else if(tokceq("lists")) {
			pd.spriteContext = stageContext;
			parseLists(&pd);
		}
		else if(tokceq("scripts")) {
			pd.spriteContext = stageContext;
			parseScripts(&pd);
		}
		else if(tokceq("children")) {
			puts("children");
			skip(&pd);
		}
		else // key isn't significant
			skip(&pd);

	} while(--i != 0);

	/*for(i = 0; i < nTokens; ++i) {
		printf("{ ");
		switch(tokens[i].type) {
		case JSMN_PRIMITIVE: printf("PRIMITIVE"); break;
		case JSMN_OBJECT: printf("OBJECT"); break;
		case JSMN_ARRAY: printf("ARRAY"); break;
		case JSMN_STRING: printf("STRING"); break;
		}
		printf(", %i, %i, %i }\n", tokens[i].start, tokens[i].end, tokens[i].size);
		}*/

	ThreadContext *threadContext;
	allocContextsForGreenFlagArray(utarray_len(pd.greenFlagScripts));
	for(threadContext = (ThreadContext*)utarray_front(pd.greenFlagScripts);
			threadContext != NULL;
			threadContext = (ThreadContext*)utarray_next(pd.greenFlagScripts, threadContext)
			) {
		addContextToGreenFlag(*threadContext);
	}
	free(pd.blockBuffer);
	free(pd.valueBuffer);
	utarray_free(pd.greenFlagScripts);
	cmph_destroy(pd.mph);
	free(pd.json);
	free(pd.tokens);
	return 0;
}
